import bpy
import numpy as np
import os
import sys
import shutil
import csv
from scipy.spatial.transform import Rotation as R


def generate_cube_with_materials(side_length, family_dir, output_dir):
    family_name = os.path.basename(os.path.normpath(family_dir))
    cube_name = f'cube_{family_name}_{side_length}'

    # Ensure the output directory exists
    output_dir = os.path.join(output_dir, cube_name)
    os.makedirs(output_dir, exist_ok=True)

    obj_file = os.path.join(output_dir, f'{cube_name}.obj')
    mtl_file = os.path.join(output_dir, f'{cube_name}.mtl')
    glb_file = os.path.join(output_dir, f'{cube_name}.glb')
    csv_file = os.path.join(output_dir, f'{cube_name}.csv')

    # Define vertices of the cube
    half_side = side_length / 2.0
    vertices = np.array([
        [half_side, half_side, -half_side],
        [half_side, -half_side, -half_side],
        [-half_side, -half_side, -half_side],
        [-half_side, half_side, -half_side],
        [half_side, half_side, half_side],
        [half_side, -half_side, half_side],
        [-half_side, -half_side, half_side],
        [-half_side, half_side, half_side]
    ])

    # Define faces of the cube (one face per material)
    faces = np.array([
        [0, 1, 2, 3],  # front
        [4, 5, 6, 7],  # back
        [0, 1, 5, 4],  # top
        [1, 2, 6, 5],  # bottom
        [2, 3, 7, 6],  # left
        [3, 0, 4, 7]   # right
    ])

    # Define normals for each face
    normals = np.array([
        [0, 0, -1],  # front
        [0, 0, 1],   # back
        [0, 1, 0],   # top
        [0, -1, 0],  # bottom
        [-1, 0, 0],  # left
        [1, 0, 0]    # right
    ])

    # List texture files in the specified directory
    texture_files = [f for f in os.listdir(family_dir) if f.endswith('.png') and os.path.basename(f).startswith('tag')]
    if len(texture_files) < 6:
        raise ValueError("At least 6 textures are needed in the directory.")

    texture_filenames = [os.path.splitext(f)[0] for f in texture_files]
    texture_idx = [int(f.split('_')[-1]) for f in texture_filenames]
    sorted_texture_files = [f for _, f in sorted(zip(texture_idx, texture_files))]

    # Copy textures to the output directory
    for texture_file in sorted_texture_files[:6]:
        src = os.path.join(family_dir, texture_file)
        dst = os.path.join(output_dir, texture_file)
        shutil.copy(src, dst)  # Use shutil to copy the file

    # Write MTL file
    with open(mtl_file, 'w') as f:
        for i, texture_file in enumerate(sorted_texture_files[:6]):
            f.write(f"newmtl material_{i}\n")
            f.write(f"Ka 0.8 0.8 0.8\n")  # Ambient color for paper-like material
            f.write(f"Kd 1.0 1.0 1.0\n")  # Diffuse color (white)
            f.write(f"Ks 0.0 0.0 0.0\n")  # Specular color (no specular reflection)
            f.write(f"Tr 1.0\n")  # Transparency (fully opaque)
            f.write(f"illum 2\n")  # Illumination model (basic lighting model)
            f.write(f"Ns 0.0\n")  # Shininess (none)
            f.write(f"map_Kd {texture_file}\n\n")
    print(f"MTL file saved to {mtl_file}")

    # Write OBJ file
    with open(obj_file, 'w') as f:
        f.write("# OBJ File Generated by Python Script\n")
        f.write(f"# Vertices: {len(vertices)}\n")
        f.write(f"# Normals: {len(normals)}\n")
        f.write(f"# Faces: {len(faces)}\n")
        f.write(f"\nmtllib {os.path.basename(mtl_file)}\n\n")

        # Write vertices
        for vertex in vertices:
            f.write(f"v {' '.join(map(str, vertex))}\n")

        f.write("\n")

        # Write normals
        for normal in normals:
            f.write(f"vn {' '.join(map(str, normal))}\n")

        f.write("\n")

        # Write texture coordinates (covering full texture per face)
        texture_coords = np.array([
            [0.0, 0.0],
            [1.0, 0.0],
            [1.0, 1.0],
            [0.0, 1.0]
        ])

        for vt in texture_coords:
            f.write(f"vt {' '.join(map(str, vt))}\n")

        f.write("\n")

        # Write faces with materials and normals
        for i, face in enumerate(faces):
            f.write(f"usemtl material_{i}\n")
            face_txt = []
            for j, v in enumerate(face):
                face_txt.append(f"{v+1}/{(j % 4) + 1}/{i+1}")
            f.write(f"f {' '.join(face_txt)}\n")
            f.write("\n")
    print(f"OBJ file saved to {obj_file}")

    # Convert OBJ to GLB using Blender
    try:
        bpy.ops.wm.read_factory_settings(use_empty=True)
        bpy.ops.import_scene.obj(filepath=obj_file)
        for mat in bpy.data.materials:
            # If the material has a node tree
            if mat.node_tree:
                # Run through all nodes
                for node in mat.node_tree.nodes:
                    # If the node type is texture 
                    if node.type == 'TEX_IMAGE':
                        # Set the interpolation -> Linear, Closest, Cubic, Smart
                        node.interpolation = 'Closest' 
            else:
                print("No material node tree found")
        bpy.ops.export_scene.gltf(filepath=glb_file, export_format='GLB')
        print(f"GLB file saved to {glb_file}")
    except Exception as e:
        print(f"Error during Blender operations: {e}")

    # Calculate transformations and save to CSV
    face_centers = {
        0: [0, 0, -half_side],  # front
        1: [0, 0, half_side],   # back
        2: [0, half_side, 0],   # top
        3: [0, -half_side, 0],  # bottom
        4: [-half_side, 0, 0],  # left
        5: [half_side, 0, 0]    # right
    }

    rotations = {
        0: [0, 0, 0, 1],                         # front
        1: [0, 0, 1, 0],                         # back
        2: R.from_euler('x', 90, degrees=True).as_quat().tolist(),  # top
        3: R.from_euler('x', -90, degrees=True).as_quat().tolist(), # bottom
        4: R.from_euler('y', 90, degrees=True).as_quat().tolist(),  # left
        5: R.from_euler('y', -90, degrees=True).as_quat().tolist()  # right
    }

    with open(csv_file, 'w', newline='') as csvfile:
        fieldnames = ['face_idx', 'translation_x', 'translation_y', 'translation_z', 'rotation_w', 'rotation_x', 'rotation_y', 'rotation_z']
        writer = csv.DictWriter(csvfile, fieldnames=fieldnames)
        writer.writeheader()

        for idx in range(6):
            translation = face_centers[idx]
            rotation = rotations[idx]
            writer.writerow({
                'face_idx': idx,
                'translation_x': translation[0],
                'translation_y': translation[1],
                'translation_z': translation[2],
                'rotation_w': rotation[3],
                'rotation_x': rotation[0],
                'rotation_y': rotation[1],
                'rotation_z': rotation[2]
            })

    print(f"CSV file saved to {csv_file}")


if __name__ == "__main__":
    # Blender passes command-line arguments as sys.argv[5:] because sys.argv[0] is the script name
    if len(sys.argv) < 5:
        print("Usage: blender -b -P <script> -- <side_length> <family_dir> <output_dir>")
        sys.exit(1)

    side_length = float(sys.argv[5])
    family_dir = sys.argv[6]
    output_dir = sys.argv[7]

    generate_cube_with_materials(side_length, family_dir, output_dir)
